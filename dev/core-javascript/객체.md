# 객체
- [ref](https://velog.io/@doondoony/JavaScript-Object#-contents)

## 객체의 생성(초기화)
- `new Object()`
- `{ }`
- `Object.create()`

### 리터럴 이외의 객체 생성은 지양해야 하는 이유
> 그래도 3가지 방법으로 만들 수 있게 한 자바스크립트의 철학이 있지 않을까? TODO
1. property 추가가 어렵다.    
Object 를 생성하고, 하나씩 프로퍼티를 추가해야 한다.
```javascript
const Square = new Object();
Square.width = 300;
Square.height = 300;
```
Object literal 을 쓰는게 낫지 않을까? 
```javascript
const Rectangle = new Object();
Object.assign(Rectangle, { width: 300, height: 300 });
```

2. Object 리터럴은 코드 길이가 작다.

## 내장 객체 (Built in Object)
1. [원시값](./원시타입과%20참조타입.html#원시타입)을 제외한 다른 
[내장 객체](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects)는 Object 의 하위 집합이다.

## primitive null, 왜 typeof null === 'object' ? 
자바스크립트를 처음 구현할 때
- `자바스크립트 값`은 `타입 태그`와 `값`으로 표시됨    
    - 작은 `type tag`(1~3 비트) + `실제 값`으로 구성된 32비트 단위로 저장  
    - `타입 태그` (object: 000, int: 1, double: 010, string: 100, boolean: 110)   
    - 객체의 타입 태그는 0. 
    - null 은 Null pointer(대부분의 플랫폼에서 0x00)로 표시됨. 
        - null 은 보편적으로 아무것도 없음을 의미하기 때문에        
        - 그 결과 null 은 타입 태그로 0을 가지며, 따라서 typeof 는 object 를 반환합니다. (참고 문서)

---
ECMAScript에 수정 제안(opt-in을 통해)
- typeof null === 'null'.
- null type check 를 위한 코드 typeof null === "object" 의 하위 호환을 맞추기 위함.
- 제안은 거절 됨.

## 프로퍼티
객체 기반 패러타임이 자바스크립트

- 객체는 프로퍼티의 집합
- 프로퍼티는 이름 값의 관계

### 프로퍼티 이름
- 프로퍼티 값에 접근하기 위한 레퍼런스 역할
- 객체 컨테이너에 보관됨 

#### 프로퍼티 이름 접근 방법
> 프로퍼티 접근과 키 접근의 명명이 다른 이유는 무엇일까? 
1. `.` 연산자
    - 프로퍼티 접근
    - 접근 문자열 : 자바스크립트 변수 이름 생성 규칙(_$0-9, A-Z,a-z) 에 허용 되는 문자열.
2. [] 연산자
    - 키 접근
    - 접근 문자열 : UTF-8 / Unicode 호환 문자열
    - `const a = {}; a['Awesome-Property!'] = 1;`
    - 원시값을 사용하면 문자열로 변환된 뒤에 사용된다.
        ```javascript
        const obj = {};
        obj[null] = 'NULL';
        obj[true] = 'TRUE';
        obj[obj] = 'Object';
                    
        console.log(obj['null']); // 'NULL'
        console.log(obj['true']); // 'TRUE'
        console.log(obj['[object Object]']); // 'Object'
        ```
3. 계산된 프로퍼티 이름
    - ES6
    - 객체 리터럴 내부에서 프로퍼티 이름을 [] 로 감싼 뒤 계산된 프로퍼티명을 사용할 수 있다.
        ```javascript
        const meow = 'MEOW';
        const obj = {
          [meow]: 'NYAN',
          [meow+meow]: 'NYAN NYAN',
        };
                        
        console.log(obj['MEOW']) // 'NYAN'
        console.log(obj['MEOWMEOW']) // 'NYANNYAN'
        ```
    - ES6 심볼 사용
        ```javascript
        const objWithSymbol = {
          [Symbol.Private]: "Private"
        };
                        
        console.log(objWithSymbol[Symbol.Private]) // "Private"
        ```

### 프로퍼티 값
자바스크립트에서 허용되는 값을 사용할 수 있다.

### 프로퍼티 특성 설명자 Property Descriptor 
ES5 이전에는 Property Descriptor 를 확인할 수 없었지만, 현재는 descriptor 값의 조회, 수정이 가능하다.
```javascript
const obj = { a: 1 };
console.log(Object.getOwnPropertyDescriptor(obj, 'a'));
// {value:1, writable: true, enumerable: true, configurable: true}
```

Ref
[:link:](https://ko.javascript.info/property-accessors)
[:link:](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

#### 프로퍼티의 종류
1. 데이터 프로퍼티 (data property)
2. 접근자 프로퍼티 (accessor property)
    - 접근자 프로퍼티의 본질은 함수
    - 이 함수는 값을 획득(get) 하고 설정(set)하는 역할을 담당한다.
    - 외부 코드에서는 함수가 아닌 일반적인 프로퍼티처럼 보인다.

둘 중 한 종류에만 속할 수 있다.
```javascript
Object.defineProperties({}, 'prop', {
    get() { // 접근자 프로퍼티의 설명자
        return 1;
    },
    value: 2    // 데이터 프로퍼티의 설명자
}) // error
```

> 설명자를 설정해본적이 없는데 어떨때 쓰는 것일까 ?

### 데이터 프로퍼티 설명자
#### value
프로퍼티 값 정의

- type: 자바스크립트에서 허용한 모든 값
- Default: undefined 

#### writable
프로퍼티 값의 수정여부

- type: Boolean
- Default: false

false 일 때, 엄격모드 여부에 따라 동작이 달라진다.
- 엄격모드 : throw Error
- 비 엄격모드 : 값 할당 실패

```javascript
const cat = {};
Object.defineProperty(cat, 'name', {
  value: 'DoonDoon',
  writable: false, // 한 번 정한 이름을 바꿀 수 없어요!
  configurable: true,
  enumerable: true,
});

cat.name = 'TT'; // 변경되지 않습니다
console.log(cat.name) // DoonDoon
```  

#### enumerable
프로퍼티 열거 가능 여부

- type: Boolean
- Default: false

for...in, Object.keys(), Object.entries(), Object.values() 등의 함수에서 프로퍼티가 열거되지 않도록 정의한다.
```javascript
const cat = {}
Object.defineProperties(cat, {
  name: {
    value: 'DoonDoon',
    writable: true,
    configurable: true,
    enumerable: true,
  },
  age: {
    value: 3,
    writable: true,
    configurable: true,
    enumerable: false, // 나이는 알리고 싶지 않아요 🐱
  },
});

for (let key in cat) { console.log(key) } // name
Object.keys(cat) // ["name"]
Object.values(cat) // ["DoonDoon"]
Object.entries(cat) // [["name", "DoonDoon"]]
```

#### configurable 
Property Descriptor 의 수정 여부

- Type: Boolean
- Default: false
---
- false 일 경우, `writable: true` ->  `writable: false` 이외에 모든 설정이 금지된다.
- 프로퍼티도 삭제할 수 없다.

```javascript
const cat = {};

Object.defineProperties(cat, {
  name: {
    value: 'DoonDoon',
    writable: true,
    enumerable: true,
    configurable: false, // name 프로퍼티에 대한 설정을 더 이상 변경할 수 없습니다
  },
  age: {
    value: 3,
    writable: true,
    enumerable: true,
    configurable: true,
  },
});

// writable 은 false 에서 true 로 한 번만 변경 가능합니다. 돌아올 수 없는 강을 건너는 거죠 🛶
Object.defineProperty(cat, 'name', { writable: false, });

try {
  Object.defineProperty(cat, 'name', { writable: true, }); // 안 바뀐다! 그리고 에러가 발생 합니다
} catch (e) {
  console.error(e); // [TypeError: Cannot redefine property: name]
}

delete cat.name // 안 지워져!

console.log(cat.name) // "DoonDoon"
console.log(Object.getOwnPropertyDescriptor(cat, 'name')); // { value: 'DoonDoon', writable: false, enumerable: true, configurable: false }
```

### 접근자 프로퍼티 설명자
Property - Accessor Descriptor

- configurable, enumerable, get, set
- value, writable 은 무시된다.

- `get` 인수가 없는 함수, 프로퍼티를 읽을 때 동작
- `set` 인수가 하나인 함수, 프로퍼티에 값을 쓸 때 호출됨
- `enumerable` 데이터 프로퍼티와 동일, 이 속성이 대상 객체의 속성 열거 시 노출된다면 true, 기본값은 false
- `configurable` 데이터 프로퍼티와 동일함. 이 속성의 값을 변경할 수 있고, 대상 객체에서 삭제할 수 있다면 true, 기본값은 false

```javascript
let obj = {
    get propName() {
        // getter, obj.propName 을 실행할 때 실행된다.
    },
    set propName(value) {
        // setter, obj.propName = value 를 실행할 때 실행되는 코드
    }
}
```
바깥 코드에선 접근자 프로퍼티를 일반 프로퍼티처럼 사용할 수 있다.
```javascript
let user = {
    name: "John",
    surname: "Smith",
    get fullName() {
        return `${this.name} ${this.surname}`;
    }
}
alert(user.fullName);
```
프로퍼티에 getter 메서드만 있기 때문에 에러가 발생한다.
```javascript
user.fullName = 'Test'; // Error
```
setter 추가
```javascript
let user = {
    // ...
    set fullName(value) {
        [this.name, this.surname] = value.split(" ");
    }
};
user.fullName = "Alice Cooper";
console.log(user.name, user.surname);   // Alice Cooper
```
fullName 은 가상의 프로퍼티 이다. 읽고 쓸 순 있지만 실존하지 않는다.

#### 자바 getters, setters 의 용도 
[:link:](https://www.quora.com/What-is-the-use-of-getters-and-setters-in-java)
[:link:](https://moonscode.tistory.com/14)
1. 유효성 검사
2. Lazy Loading
3. Read 와 Write 권한을 다르게 설정

클래스 외부에서 클래스의 private 필드 를 get/set 할때 사용한다.
- 클래스 필드를 실수로 조작하지 못하도록 `유효성 검사`를 수행 할 수있는 중심 위치. 

- 캡슐화 
- 동시성과 멀티스레딩에서 중요한 역할 
    - 객체를 동시에 실행중인 다른 스레드로 전달하려면,
    [race condition](https://ko.wikipedia.org/wiki/%EA%B2%BD%EC%9F%81_%EC%83%81%ED%83%9C) 
    및 기타 멀티스레딩의 부작용을 피하기 위해 스레드들을 동기화 해야 한다.
    - 불변 객체의 경우 객체 상태가 스레드에 의해 변경될까봐 걱정할 필요가 없다.
    - 불변 객체 예제
        ```java
        public class MyObject {
            // 모든 멤버 변수는 private - 캡슐화, final 
            private final int state;
            private final String str;
            // constructor(생성자) 는 변수를 정의 할 수있는 마지막 장소이다.
            public MyObject(int state, String str) {
                this.state = state;
                this.str = str;
            }	
            
            //Getters
            public int getState() {
                return this.state;		
            }
            
            public String getStr() {
                return this.str;
            }
            // 객체의 상태의 불변성을 위해 setter 가 없다.
        }
        ```

### getter 획득자 메서드
- [ref](https://wesbin.tistory.com/32)
- 보통은 계산된 값 반환할 때 사용.

#### 구문
- 함수 이름     
    - 자바스크립트 변수 이름 생성 규칙(_$0-9, A-Z,a-z) 에 허용 되는 문자열.
- 매개변수가 없다.

#### 선언
```javascript
var log = ['test'];
var obj = {
  get latest () {
    if (log.length == 0) return undefined;
    return log[log.length - 1]
  }
}
```
프로퍼티 접근을 해도, 정의된 함수가 호출되고 값이 반환된다.
```javascript
console.log (obj.latest); // "test"를 반환.

```
#### 삭제
```javascript
delete obj.latest
```
#### defineProperty, 객체에 새 프로퍼티로 추가
```javascript
const obj = { _name: 'DoonDoony' }
Object.defineProperty(obj, 'name', {
    get: function() {
        return `${this._name} the Cat!`
    },
    enumerable: true,
    configurable: true,
})
console.log(obj.name) // "DoonDoony the Cat!"
```
#### 계산된 프로퍼티 이름
```javascript
const prefix = 'name';
const obj = { 
  get [prefix] () { 
    return 'Getter is called with prefix' 
  }
}
```
#### Immutable 패턴
객체의 생명주기 동안 내부의 상태가 절대 변경되지 않도록 강제하는 방법
- 객체의 프로퍼티 값 할당을 생성자를 통해서만 할 수 있다.
- 필드에 접근하기 위해서는 Getter 메서드를 사용해야 한다.
```javascript
const _list = new WeakMap();
const key = new Object();

class SomeClass {

    constructor(list) {
	_list.set(key, list);
    }

    // 필드 자체 값 대신에 복사본을 반환
    getList() {
        // 객체를 복제하는 clone()이라는 메서드가 있다고 가정
        return _list.get(key).clone();
    }
}
```

---
#### lazy evaluation 
getter 프로퍼티에 접근하기 전까지는 값을 계산하지 않는다.     
- 값의 계산 비용이 큰 경우 
    - RAM 이나 CPU 의 시간을 많이 소모할 때
    - worker thread 생성 
    - 원격 파일 로드 
- 값이 당장 필요하지 않을때, 나중에 이용될 때, 절대로 이용되지 않을 때
- 값이 다시 계산되어서는 안되는 경우.
> 각 케이스가 궁금하다 TODO

---
#### getter 반환값의 캐싱 
- getter 은 첫 호출 이후에는 다시 계산하지 않고 이 캐시 값을 반환한다.

무슨 말이냐 하면, setter 에서 delete 를 하든 getter 에서 delete 를 하든, delete 를 호출하면 setter, getter 모두가 해제 됩니다.
그래서 `o.foo = "test"` 를 할 때 getter 인 foo 가 이미 삭제되었기 때문에 `console.log(o.foo)` 는 `get foo() {}` 를 실행시키는 것이 아니라 o.foo 프로퍼티의 값을 반환하여 "test" 를 출력하게 되는 것입니다.
```javascript
var o = {
  _foo: '',
  set foo (val) {
    delete this.foo;
    this.foo = val;
  },
  get foo () {
    delete this.foo;
    return this.foo = 'something';
  }
};

o.foo = "test";
console.log(o.foo); // 'test' 출력
```
[:link:](https://stackoverflow.com/questions/63118365/why-use-delete-on-a-javascript-objects-getter-and-setter/63128616#63128616)
`o.foo = "test"` 이후의  setter 가 활성화 되고, `delete this.foo` 는 setter 를 삭제하여 
다음줄의 `this.foo` 는 객체의 프로퍼티에 값을 할당하게 됩니다.
그러나 만약에 `delete this.foo` 가 없다면, `this.foo`는 다시 setter 를 호출하게 되므로 `throws RangeError maximum call
`를 유발합니다. 이것의 대안은 `this._foo` 처럼 프로퍼티 명을 private 형식으로 지정해 줄 수 있습니다.


```javascript
var o = {
  set foo (val) {
    this._foo = val;
  },
    // ...
};
```

`get foo() { delete this.foo }` foo 프로퍼티를 삭제해도 결과는 `test` 을 출력한다. 왜 delete 를 적어준 것일까요?
- 다시 o.foo 를 얻어 올때, getter 으로 값을 다시 계산하는 것을 없애기 위해서 입니다. 단순히 o의 프로퍼티인 foo 로서 값을 얻어 옵니다.
```javascript
var o = {
  _foo: '',
  set foo (val) {
    this._foo = val;
  },
  get foo () {
    return this._foo = 'something';
  }
};
```

- 문자열을 반환하는 이유
    - 자바스크립트에서 할당문은 할당한 값을 반환 (const, let, var 키워드 제외)  
이 예제는 getter 와 setter 를 캐싱으로서 사용하지 않을 때 입니다.
```javascript
o.foo = "test"; //test 
o.foo; // something
```
아무리 setter 를 해서 _foo 의 값을 변경 시켜도, `o.foo` 으로 getter 를 호출해도 항상 'something' 으로 됩니다. `this._foo = 'something'`에서 다시 setter 를 호출하기 때문입니다.
이 예제는 도대체 왜 만든건지 모르겠네요. 

중요한 것은, 캐싱을 위해 의도적으로 getter 와 setter 를 사용할 수 있다는 점 같습니다.

활용  
- 값의 계산 비용이 큰 경우 
    - RAM 이나 CPU 의 시간을 많이 소모할 때
    - worker thread 생성 
    - 원격 파일 로드 
- 값이 여러차례 이용되지만, 절대 변경되지 않아 매번 다시 계산할 필요가 없을 때
- 값이 다시 계산되어서는 안되는 경우.

### setter 설정자 메서드

```javascript
const cat = {
  _name: undefined,
  set name(newName) {
    this._name = newName;
  },
  call() {
    console.log(this._name);
  },
};

cat.name = 'DoonDoony';
cat.call(); // 'DoonDoony'
```

setter 에서 값을 할당하는 내부적 과정
#### 1. 접근하는 프로퍼티 탐색 
직속 프로퍼티

---
1. 접근하는 프로퍼티가 Accessor Descriptor(Getter/Setter) 일 때
    - [Setter] 호출.
    - [Setter] 가 없고 [Getter]만 있을 때
        - 값 할당은 무시된다.
2. 접근자 설명자가 아니고, `writable: false` 일 때
    - 조용히 실패
    - 엄격모드일 땐, Type Error 발생
3. 1번 2번 모두 해당하지 않을때, 프로퍼티에 값을 세팅

#### 접근하는 프로퍼티가 없을 때
객체와 연결된 상위 [[Prototype]] 체인을 순회한다.

#### 2. 모든 [[Prototype]] 체인에서 프로퍼티가 발견되지 않을 경우
---
1. Object extensible
    - 직속 프로퍼티(Directly Present) 생성하고 값을 할당
2. not Object extensible
    - Object.preventExtensions(), Object.isExtensible()[false] 일 때, 
    - `TypeError` 발생
    - 프로퍼티의 삭제/수정 가능
    - 오브젝트의 __proto__ 에 값 추가, 변경 가능
```javascript
'use strict';

const parentCat = {
  name: 'DoonDoon',
  age: 10,
};

const childCat = Object.create(parentCat);
Object.assign(childCat, { name: 'DoonDoony', age: 3, favorite: 'Red Ball' });
```
childCat 을 확장 불가능하게 만듭니다
```javascript
Object.preventExtensions(childCat);
// childCat 이 확장 불가능한지 확인합니다
console.log(Object.isExtensible(childCat)); // false
```
기존의 프로퍼티를 수정합니다
```javascript
childCat.favorite = 'Box';
console.log(childCat.favorite); // Box
```
기존의 프로퍼티를 삭제합니다
```javascript
delete childCat.favorite; // true
console.log(childCat.favorite); // undefined
```
[[Prototype]] 에 새 프로퍼티를 추가합니다
```javascript
childCat.__proto__.gender = 'male';
console.log(Object.getPrototypeOf(childCat)); // { name: 'DoonDoon', age: 10, gender: 'male' }
```
TypeError!
```javascript
childCat.gender = 'male';
```  
    
#### 3. 상위 [[Prototype]] 체인에서 프로퍼티가 발견된 경우 [:link:](https://ju-note.tistory.com/17)
1. `writable: true` 
    - 직속 프로퍼티를 생성하고 값을 할당
        - 의도는 상위 수준의 프로퍼티에 할당을 하려고 했지만 직속 프로퍼티가 추가 된다.
        - 객체지향에서 Overriding 이라고 부르는 Shadowing 이 발생한다. 
    ```javascript
    let anotherObj = {
        a: 2,
    };
    
    let myObject = Object.create(anotherObj);
    
    console.log(anotherObj.a);
    console.log(myObject.a);
    
    console.log(anotherObj.hasOwnProperty('a'));  //ture 
    console.log(myObject.hasOwnProperty('a'));  // false
    ```
    이것이 위임을 통한 프로퍼티 가려짐이다. anotherObj.a가 증가함이 아니라. myObject에 a가 새로 할당된다.
    ```javascript
    console.log(myObject.a++); // 2;  
    
    console.log(anotherObj.a);  //2 ;
    console.log(myObject.a); // 3;
    
    console.log(myObject.hasOwnProperty('a'));  // true
    ```
2. `writable: false`
    - 아무일도 일어나지 않는다.
    - 엄격모드일 경우 TypeError
    
프로퍼티가 [Setter] 일 경우, 항상 Setter 가 호출된다.
- 직속 프로퍼티가 추가 되지 않는다.
- Setter 를 덮어 쓰려면 `Object.defineProperty` 를 사용해야 한다.



### getter 와 setter 똑똑하게 활용하기
1. 실제 프로퍼티 값을 감싸는 wrapper 처럼 사용 하면, 프로퍼티 값을 원하는 대로 통제할 수 있다.
```javascript
let user = {
    get name () {
        return this._name;
    },
    set name (value) {
        if (value.length < 4) {
            alert('입력값이 너무 짧습니다. 4자 이상으로 입력하세요.');
            return;
        }
        this._name = value;
    }   
};
user.name = "Pete";
alert(user.name);

user.name = "";
```
user._name 으로 접근할 수 있지만.  
_ 밑줄로 시작하는 프로퍼티는 객체 내부에서만 활용하고, 외부에서는 건드리지 않는 것이 관습.

2. 호환성을 위해 사용하기     
데이터 프로퍼티 name, age 를 사용해서 사용자를 나타내는 객체 구현
```javascript
function User(name, age) {
    this.name = name;
    this.age = age;
}
let john = new User("John", 25);
alert(john.age);   // 25
```
요구사항이 바뀌어 age 를 birthday 로 저장해야 할 경우. (birthday 가 더 정확하고 편리하기 때문)
```javascript
function User(name, birthday) {
    this.name = name;
    this.birthday = birthday;
}
let john = new User("John", new Date(1992, 6, 1));
```
기존 코드에 age 를 사용하고 있는 코드를 모두 찾아서 수정해야 하는 문제점이 있다.

```javascript
function User(name, birthday) {
    this.name = name;
    this.birthday = birthday;
    Object.defineProperties(this, 'age', {
        get() {
            let todayYear = new Date().getFullYear();
            return todayYear - this.birthday.getFullYear();
        }
    });
}
let john = new User('John', new Date(1992, 6, 1));
alert(john.birthday);
alert(john.age);
```

### Property - Existence
객체에 프로퍼티가 존재하는지 여부를 확인하는 방법

```javascript
const parent = { parentProp: 'Hey' };
const child = Object.create(parent);
child.childProp = 'Yay!';
```
1. `in` 연산자
    - [[Prototype]] 체인을 모두 순회하며 키 존재 여부를 검사한다.
    ```javascript
    console.log('parentProp' in child) // true
    ```
2. `Object.hasOwnProperty`
    - 직속 프로퍼티 존재 여부만을 검사한다.
    ```javascript
    console.log(child.hasOwnProperty('parentProp')); // false
    console.log(child.hasOwnProperty('childProp')); // true
    ```

### Object.seal & Object.freeze
#### Object.seal
```javascript
'use strict';
const obj = { a: 1, b: 2 };
Object.seal(obj);
```
- 더 이상 확장 불가능 하게 만듦(프로퍼티 추가가 불가능한 상태)
    ```javascript
    try {
      obj.c = 3;
    } catch (e) {
    // 확장 불가능 하기 때문에, TypeError!
      console.error(e); // TypeError: Cannot add property c, object is not extensible
    }
    ```
- Object.defineProperty 로 Descriptor 를 변경하는 행위를 막음
    ```javascript
    try {
        Object.defineProperty(obj, 'b', { enumerable: false });
      } catch (e) {
        // 설정 불가능 하기 때문에, TypeError!
        console.error(e); // TypeError: Cannot redefine property: b
      }
    ```
- 프로퍼티 삭제 불가
    ```javascript
     try {
        delete obj.a;
      } catch (e) {
        // 삭제 불가능 하기 때문에, TypeError!
        console.error(e); // TypeError: Cannot delete property 'a' of #<Object>
      }
    ```
  
#### Object.freeze
Object.seal 의 모든 동작을 포함하고, 프로퍼티 값 또한 변경 불가능 하게 만든다.          
중첩된 접근 값이 변경은 가능하다.     
obj.a = { b: 1 } 이라면 obj.a 는 변경 불가 하지만, obj.a.b 는 변경 가능합니다

## 객체의 복사
얕은 복사
- `Object.assign`
- Object Spread Operator ({...});
- object(배열, 함수 포함) 이면, 참조로 복사 되기 때문에 배열, 객체, 함수에 대한 변경이 생기면
  모든 복사된 객체가 공유한다
  
---
깊은 복사
- `JSON.stringify`
- `JSON.parse`
- JSON 직렬화가 불가능한 함수는 프로퍼티가 될 수 없다.

## ES6 Object Syntax
```javascript
const doondoony = {
  name: 'DoonDoony',
  age: 3,
  favorite: 'Red Ball',
  color: ['white', 'coffee'],
};
```
1. Object Spread Operator
doondoony 객체의 모든 값을 복사하고, 중복되는 프로퍼티는 업데이트
```javascript
const doondoonyJr = { ...doondoony, name: 'DoonDoon', age: 1 };
```
2. Rest Parameter
```javascript
const { name, ...rest } = doondoony;
const { catName, ...rest } = doondoony;
```
3. Object Destructuring
```javascript
const { name, age } = doondoony;

function howOldAreYou ({ name, age }) { }
```
4. Property Value Shorhand (프로퍼티 할당 단축구문)
```javascript
function makeCuteCat (name, age, color) {
  return {
    name, // name: name 이라고 원래는 작성해야 했었지만, 단축 구문을 사용하면 같은 동작을 합니다
    age,
    color,
  };
}
```
5. Method definition shorthand(메서드 정의 축약 문법)
```javascript
const doondoony = {
    // speak: function() {} 과 같은 방식에서 축약 해서 작성할 수 있습니다
    speak () {
        console.log(this.name);
    },
};
```
6. 
 

## 객체와 메서드
`객체` (유일무이한) 실존하는 개체(entity)를 표현하고자 할 때 생성한다.
```javascript
let user = {    
    name: 'John',
    age: 30,
}
```
예) 사용자(user), 주문(order)  
사용자는 현실에서, 장바구니에서 물건 선택, 로그인, 로그아웃 등의 행동을 한다.  
`객체 프로퍼티에 함수 할당 ` 마찬가지로 사용자를 나타내는 객체 user 도 특정한 행동을 할 수 있다.

## 메서드 만들기
객체 user 에게 인사할 수 있는 능력 부여

`메서드` 객체 프로퍼티에 할당된 함수
### 함수 표현식
- 함수 표현식으로 함수를 만든다.
- user.sayHi 에 함수를 할당한다.
```javascript
let user = {
    name: 'John',
    age: 30,
}
user.sayHi = function() {
    alert('안녕하세요!');
}
user.sayHi();
```
### 함수 선언식
```javascript
function sayHi () {
    alert('안녕하세요');
}
user.sayHi = sayHi;
user.sayHi();
```

### 객체지향 프로그래밍
객체를 사용하여 개체를 표현하는 방식

### 메서드 단축 구문
두 구분이 완전히 동일하지는 않다.
객체 상속과 관련된 미묘한 차이가 존재한다. TODO
```javascript
user = {
    sayHi: function() {
        alert('Hello');
    }
};
```
```javascript
user = {
    sayHi () {
        alert('Hello');
    }
};
```

## 메서드와 'this'
메서드는 객체에 저장된 정보에 접근할 수 있어야 제 역할을 할 수 있다.

대부분의 메서드는 객체 프로퍼티의 값을 활용한다.

> TODO 객체 프로퍼티의 값을 활용하지 않는 메서드의 예로는 무엇이 있을까? 

```javascript
let user = {
    name: "John",
    age: 30,
    sayHi() {
        alert(this.name);
    }
};
user.sayHi() // John
```
this 대신 user 사용했을 때, 예상치 못한 에러가 발생할 수 있다.
```javascript
let user = {
    name: "John",
    age: 30,
    sayHi() {
        alert(user.name);   // Error: Cannot read property 'name' of null
    }
}
let admin = user;
user = null;
admin.sayHi();  // sayHi() 가 엉뚱한 객체를 참고하면서 에러가 발생함.
```


## 복합 객체 (합성 객체) [:link:](https://neeunbox.tistory.com/14)
Q. 신정웅님 '객체나 함수와 같은 것을 합성 값이라고 부르는 이유?'

복합 객체는 여러 값을 하나로 합친 합성체이며, 여러 값을 복합적으로 구성할 수 있다는 점에서 원시값과 구별된다.


## 함수
object 의 하위타입.
Callable Object [[Call]] 로 호출 가능한 객체라 명시됨.

- function 에는 name 프로퍼티가 있다. 
- length 도 있다. (인자의 개수)


## 배열
인덱스에 키 / 프로퍼티 문자열을 추가 할 수 있지만 length 가 증가하지 않는다.     
```javascript
const arr = [];
arr['test'] = 'test';
console.log(arr.length);    // 0
console.log(arr['test']);   // 'test'
```
키로 넣은 문자열이 10진수 숫자 타입으로 바뀌면 숫자 키를 사용한 결과를 초래 할 수 있다.
```javascript
arr['0'] = 1;
console.log(arr.length);    // 1
console.log(arr[0])         // 1
```
    
## 참조형(reference type)  
[:link:](https://epthffh.tistory.com/entry/Javascript-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-%E2%80%93-JS-Flow%EA%B8%B0%EB%B3%B8%ED%98%95%EA%B3%BC-%EC%B0%B8%EC%A1%B0%ED%98%95)
참조된 주소를 할당

참조형 과정
- 변수에 주소 할당
- 주소에는, 주소와, 데이터가 있음
- ...반복

### 종류
- 객체(Object) 

- 배열(Array)

- 함수(Function) 

- 날짜(Date)

- 정규표현식(RegExp)

(ES6에서 추가됨)
- Map [:link:](./문법%20사전#Map)
- WeakMap [:link:](./문법%20사전#WeakMap)
- Set [:link:](./문법%20사전#Set)
- WeakSet 등 [:link:](./문법%20사전#WeakSet)

### 사실상 모두다 객체다!

## JavaScript Collections [:link:](https://velog.io/@yesdoing/JavaScript-Collections)
TODO

