# 비동기 프로그래밍

## Motivation - 타이머 API
자바스크립트 개념이 아닌 브라우저와 node.js 에서 부터 왔다. 
      
setTimeout 
- 인자 (callback, msTime) : msTime 후에 callback 실행
- msTime : callback 이 실행의 최소 대기시간, 지연될 수 있다.

setInterval 
- msTime 을 1000ms 이하로 지정하였을 때
    - 브라우저에 따라 msTime 을 강제로 set 시킨다. 
    - 크롬의 경우, 1000ms 으로 set 한다.

여기서 왜 setTimeout 의 일정시간을 지키지 않고 지연되어 실행되는 이유가 무엇인지 알아보자.

## 브라우저의 JavaScript 코드 실행 과정
### 호출 스택 (Call Stack)
JS 엔진은 함수 호출 관련정보를 콜스택에서 관리한다.

```javascript
function add(x, y) {
  return x + y;
}

function add2(x) {
  return add(x, 2); // `add`를 호출
}

function add2AndPrint(x) {
  const result = add2(x); // `add2`를 호출
  console.log(result); // `console.log`를 호출
}

add2AndPrint(3); // `add2AndPrint`를 호출
```
위 코드의 호출스택 상태 변화는 아래와 같다.  
 
<img src="https://user-images.githubusercontent.com/31977543/91665967-54b20100-eb34-11ea-87fb-0db6b7b7b4fa.png" style="width: 200px"/>
<img src="https://user-images.githubusercontent.com/31977543/91665973-61cef000-eb34-11ea-8418-f8d9b1ca4429.png" style="width: 200px"/>
<img src="https://user-images.githubusercontent.com/31977543/91665980-70b5a280-eb34-11ea-8e4e-2c9d0f5dad78.png" style="width: 200px"/>
<img src="https://user-images.githubusercontent.com/31977543/91665973-61cef000-eb34-11ea-8418-f8d9b1ca4429.png" style="width: 200px"/>
<img src="https://user-images.githubusercontent.com/31977543/91665967-54b20100-eb34-11ea-87fb-0db6b7b7b4fa.png" style="width: 200px"/>

### 실행 맥락 (Execution context)
call stack 에 저장되는 각 항목

#### Execution Context 의 요소들
[렉시컬 환경](./렉시컬%20환경)

- Environment Record
    - 함수 내부에서 사용되는 변수 
    - this 가 가리치는 객체 
- outer Lexical Environment 

### 브라우저가 JavaScript 코드를 실행할 때, 호출 스택의 변화
1. 스크립트를 로드 할 때
    - **전역실행맥락(Global Execution Context)** 을 호출 스택에 push
1. 함수가 호출 될 때
    - 함수 호출의 실행 맥락 생성
    - **함수 호출의 실행 맥락**을 호출 스택에 push
1. 함수의 실행이 끝날 때
    - 결과값 반환
    - 호출 스택의 가장 위에 있는 실행 맥락 pop
1. 스크립트의 실행이 모두 끝날 때
    - 전역 실행 맥락을 호출 스택에서 pop
    
웹 브라우저는 호출 스택에 실행 맥락이 존재하는 동안(실행 중인 함수가 존재하는 동안) 먹통이 된다.
- 브라우저의 주사율, 보통 60fps, 대략 16 ms 안에 코드 실행을 완료되지 않으면
    - 브라우저 내 애니매이션이 뚝뚝 끊기는 현상
    - 사용자 경험에 악영향

### 작업 큐 (Task Queue)
작업 큐에는 16 ms 안에 처리하는 것이 어려운 일들 이 들어간다.
- event 를 기다리는 일
- 계산이 오래걸리는 작업
- 스크립트나 모듈을 로딩하는 동작

### 브라우저의 행동 : 이벤트 루프 (Event Loop)
브라우저가 아래 행동을 끊임 없이 반복하는 것을 이벤트 루프라고 부른다.

1. 태스크 처리 위임
    - From : JS 엔진
    - To : API 를 통해(TODO)
        - 브라우저 혹은 Web Worker(message 이벤트에 이벤트 리스너 등록) 에 위임
        - 태스크가 끝나면 실행시킬 `콜백` 등록
1. 위임된 태스크가 끝남
    - 태스크의 **반환값**과 **콜백**을 작업 큐(task queue) 에 추가
1. 브라우저는 호출 스택이 비워질 때 마다
    - 작업 큐에서 가장 오래된 작업을 꺼낸다.
    - 작업에 대한 콜백을 실행 시킨다. 

<embed src="https://helloworldjavascript.net/images/eventloop.svg" onload="onKSLoad(this)" data-loop="">

### 호출 스택과 작업 큐의 성질
1. 호출 스택이 비워져야 Task Queue 의 다음 태스크가 실행된다.
1. 각 태스크 사이에 브라우저는 화면을 새로 그릴 수 있다.
    - 호출스택이 비워질 때
    
## 비동기 프로그래밍 Asynchronous Programming

### 비동기 & 동기 프로그래밍
비동기 프로그래밍
- 태스크의 완료를 기다리지 않고 다음 코드를 실행해 나간다.
동기식 프로그래밍
- 태스크가 완료될 때까지 코드의 실행을 멈추고 기다린다.

### 비동기 프로그래밍의 특징
- 장점 : 대개 프로그램의 성능과 응답성을 높인다.
- 단점 : 코드의 실행 순서가 뒤죽박죽이 된다.
    - 코드의 가독성 저하
    - 디버깅의 어려움
    
## 비동기 프로그래밍 기법
비동기 프로그래밍의 단점을 극복하기 위한 JavaScript 의 프로그래밍 기법들이 존재한다.

### 콜백 (Callback)
다른 함수의 인수로 넘기는 함수

예시) Github 의 create-react-app 프로젝트에 등록되어 있는 이슈 목록을 가져와서 출력하는 코드
```javascript
const $ = require('jquery');
const API_URL = 'https://api.github.com/repos/facebookincubator/create-react-app/issues?per_page=10';

$.ajaxSetup({
  dataType: 'json'
});

$.get(API_URL, issues => {
  console.log('최근 10개의 이슈:');
  issues
    .map(issue => issue.title)
    .forEach(title => console.log(title));
  console.log('출력이 끝났습니다.');
});

console.log('받아오는 중...');
```
- $.get 메소드
    - 비동기식 동작
    - Github API 서버 통신 태스크를 브라우저에 위임한 후 종료된다.
    - 통신이 끝난 후 그 결과를 첫번째 인수로 해서 콜백을 호출한다.
   
더 복잡한 예시) 
1. Github 에 공개되어있는 저장소 중, 언어가 JavaScript 이고 별표를 가장 많이 받은 저장소를 불러온다.
1. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다.
1. 해당 기여자들이 최근에 Github 에서 별표를 한 저장소를 각각 10개씩 불러온다.
1. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다.

데이터 흐름이 조금만 복잡해져도 코드가 복잡해지는 문제가 생긴다.

```javascript
const $ = require('jquery');
const API_URL = 'https://api.github.com';
const starCount = {};

$.ajaxSetup({
  dataType: 'json'
});

// 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다.
$.get(`${API_URL}/search/repositories?q=language:javascript&sort=stars&per_page=1`, result => {
  // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다.
  $.get(`${API_URL}/repos/${result.items[0].full_name}/contributors?per_page=5`, users => {
    let repoArrs = [];
    for (let user of users) {
      // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각 기여자마다 10개씩 불러온다.
      $.get(`${API_URL}/users/${user.login}/starred?per_page=10`, repos => {
        repoArrs.push(repos);
        // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다.
        if (repoArrs.length === 5) {
          for (let repoArr of repoArrs) {
            for (let repo of repoArr) {
              if (repo.full_name in starCount) {
                starCount[repo.full_name]++;
              } else {
                starCount[repo.full_name] = 1;
              }
            }
          }
          console.log(starCount);
        }
      });
    }
  });
});

console.log('fetching...');
```

#### 콜백의 에러 처리
```javascript
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`${src}를 불러오는 도중에 에러가 발생했습니다.`));

  document.head.append(script);
}

loadScript('/my/script.js', function(error, script) {
  if (error) {
    // 에러 처리
  } else {
    // 스크립트 로딩이 성공적으로 끝남
  }
});

```

### Promise 
언젠가 끝나는 작업의 결과값을 담는 객체

가수는 앨범이 출시되면 팬들이 자동으로 소식을 받아볼 수 있도록 하고싶어한다. 
1. 구독 리스트를 하나 만들어 팬들에게 전달해 이메일 주소를 적게 한다. 
1. 앨범이 준비되면 리스트에 있는 팬들에게 메일을 보내 앨범 관련 소식을 바로 받아볼 수 있게 한다.
1. 출시 예정인 앨범이 취소되는 불상사가 발생해도 관련 소식을 팬들에게 전달 할 수 있게 한다.



#### Promise 객체 생성
정적 메서드 `Promise.resolve`
```javascript
const p = Promise.resolve(1);
```
결과값 1 을 갖는 Promise 객체 생성


#### 비동기 작업을 하는 Promise 객체 생성
```javascript
const p = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log('2초가 지났습니다. ');
        resolve('hello');
    }, 2000);
})
```

#### Promise 생성자
- Promise 생성자의 인수 : 콜백
- 콜백의 첫번째 인수 : resolve 함수
    - 콜백 안에서 resolve(인수 값) 를 호출
    - (인수 값)이 Promise 객체의 결과 값
- 콜백의 두번째 인수 : reject 함수
    - 비동기 작업에서 에러가 발생했을 때 호출하는 함수

위 예제에서 p 는 콜백의 resolve 가 호출될 때, 결과값을 갖는 객체(Promise 객체)가 된다.

#### then : Promise 결과값에 대한 추가 작업
- Promise 객체에 then 메서드를 사용할 수 있다.
- then 메서드의 첫번째 인수: 콜백
- 콜백의 첫번째 인수 : Promise 객체의 결과값

```javascript
p.then(msg => {
  console.log(msg); // hello
});
```
- then 메서드의 반환 값 : Promise 객체
- then 메서드의 return 값 : Promise 객체의 결과 값

```javascript
const p2 = p.then(msg => {
  return msg + ' world';
});

p2.then(msg => {
  console.log(msg); // hello world
});
```
```javascript
p.then(msg => {
  return msg + ' world';
}).then(msg => {
  console.log(msg);
});
```

#### HTTP 통신의 Promise
`axios.get()` 함수는 Promise 객체를 반환한다.

```javascript
const axios = require('axios');
const API_URL = 'https://api.github.com';

axios.get(`${API_URL}/repos/facebookincubator/create-react-app/issues?per_page=10`)
  .then(res => {
    console.log('최근 10개의 이슈:');
    res.data
      .map(issue => issue.title)
      .forEach(title => console.log(title));
    console.log('출력이 끝났습니다.');
  });
```

#### Promise 장점
- then 메서드 : 콜백을 중첩하지 않고도 비동기 작업을 연이어 할 수 있다.
- 비동기 작업을 값으로 다룰 수 있다.

콜백의 비동기 프로그래밍의 복잡한 예시와 코드를 비교해 보자
```javascript
const API_URL = 'https://api.github.com';
const starCount = {};
const axios = require('axios');

// 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다.
axios.get(`${API_URL}/search/repositories?q=language:javascript&sort=stars&per_page=1`)
  // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다.
  .then(res => axios.get(`${API_URL}/repos/${res.data.items[0].full_name}/contributors?per_page=5`))
  // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다.
  .then(res => {
    const ps = res.data.map(user => axios.get(`${API_URL}/users/${user.login}/starred?per_page=10`));
    return Promise.all(ps);
  })
  .then(ress => Promise.all(ress.map(r => r.data)))
  // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다.
  .then(repoArrs => {
    for (let repoArr of repoArrs) {
      for (let repo of repoArr) {
        if (repo.full_name in starCount) {
          starCount[repo.full_name]++;
        } else {
          starCount[repo.full_name] = 1;
        }
      }
    }
    console.log(starCount);
  });

console.log('fetching...');
```

#### Promise.all(iterable) 
여러 프로미스의 결과를 집계할 때 사용한다.

TODO 실제로 어떨때 사용이 될까?

```javascript
const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});

Promise.all([promise1, promise2, promise3]).then((values) => {
  console.log(values);
});
// expected output: Array [3, 42, "foo"]

```

**매개변수 : `iterable` 객체**
- 프로미스가 아닌 값을 포함할 수 있다.
- 이미 이행된 프로미스 객체를 포함할 수 있다. 

**반환 값**
- iterable 객체가 비어있을 때 
    - 이미 이행한 Promise 반환. 
- iterable 객체 중 프로미스가 없을 때
    - 비동기 적으로 이행하는 Promise.
    - 크롬 58 은 이미 이행한 프로미스 반환  
- 위의 두가지에 해당되지 않을 때
    - Promise 가 모두 이행 된 후, 새 Promise 객체를 반환한다.
    - 요소 중 하나라도 거부가 될 때, reject 된다. 

아래의 예시에서 뜻을 확인할 수 있다.

##### Promise.all 의 동기성/ 비동기성

Promise.all 의 비동기성을 보이는 예제 
```javascript
// Promise.all을 최대한 빨리 완료시키기 위해
// 이미 이행된 프로미스로 배열을 만들어 인자로 전달 
var resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)];

var p = Promise.all(resolvedPromisesArray);
// 실행 즉시 p의 값을 기록
console.log(p);

// 호출 스택을 비운 다음 실행하기 위해 setTimeout을 사용
setTimeout(function() {
    console.log('the stack is now empty');
    console.log(p);
});

// 로그 출력 결과 (순서대로):
// Promise { <state>: "pending" } 
// the stack is now empty
// Promise { <state>: "fulfilled", <value>: Array[2] }
```

Promise.all()이 거부하는 경우에도 비동기성을 보인다
```javascript
var mixedPromisesArray = [Promise.resolve(33), Promise.reject(44)];
var p = Promise.all(mixedPromisesArray);
console.log(p);
setTimeout(function() {
    console.log('the stack is now empty');
    console.log(p);
});

// 출력
// Promise { <state>: "pending" } 
// the stack is now empty
// Promise { <state>: "rejected", <reason>: 44 }
```

- iterable 객체가 비어있는 경우에는 동기적으로 이행된다.
- 프로미스가 아닌 값은 무시하지만 비동기적으로 실행됨 
```javascript
var p = Promise.all([]); // 즉시 이행함
var p2 = Promise.all([1337, "hi"]); // 프로미스가 아닌 값은 무시하지만 비동기적으로 실행됨
console.log(p);
console.log(p2);
setTimeout(function() {
    console.log('the stack is now empty');
    console.log(p2);
});

// 출력
// Promise { <state>: "fulfilled", <value>: Array[0] }
// Promise { <state>: "pending" }
// the stack is now empty
// Promise { <state>: "fulfilled", <value>: Array[2] }
```

#### Promise.race(iterable)

TODO 실제로 어떨때 사용이 될까?


- Promise 객체를 반환
    - iterable 에서 처음으로 이행하거나 거부한 프로미스의 값을 비동기적으로 전달받는 대기중인 Promise
    - iterable 이 비어있을 경우
        - 반환한 Promise 는 영원히 대기 상태가 된다.
    - iterable 에 프로미스가 아닌값, 이미 완료된 프로미스가 포함될 경우
        - 전달받은 iterable 에서 처음으로 등장하는 이러한 값을 결과값으로 이행한다

- Promise.race 의 비동기성
    ```javascript
    // Promise.race를 최대한 빨리 완료시키기 위해
    // 이미 이행된 프로미스로 배열을 만들어 인자로 전달
    var resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)];
    
    var p = Promise.race(resolvedPromisesArray);
    // 실행 즉시 p의 값을 기록
    console.log(p);
    
    // 호출 스택을 비운 다음 실행하기 위해 setTimeout을 사용
    setTimeout(function(){
        console.log('the stack is now empty');
        console.log(p);
    });
    
    // 로그 출력 결과 (순서대로):
    // Promise { <state>: "pending" }
    // the stack is now empty
    // Promise { <state>: "fulfilled", <value>: 33 }
    ```    

- 비어있는 iterable : 프로미스는 영원히 대기 상태가 된다.
    ```javascript
    var foreverPendingPromise = Promise.race([]);
    console.log(foreverPendingPromise);
    setTimeout(function(){
        console.log('the stack is now empty');
        console.log(foreverPendingPromise);
    });
    
    // 로그 출력 결과 (순서대로):
    // Promise { <state>: "pending" }
    // the stack is now empty
    // Promise { <state>: "pending" }
    ```
- iterable 에 프로미스가 아닌 값 || 이미 완료된 프로미스 
    - 전달받은 iterable 에서 처음으로 등장하는 이러한 값을 결과값으로 이행한다 

```javascript
var foreverPendingPromise = Promise.race([]);
var alreadyFulfilledProm = Promise.resolve(666);

var arr = [foreverPendingPromise, alreadyFulfilledProm, "프로미스 아님"];
var arr2 = [foreverPendingPromise, "프로미스 아님", Promise.resolve(666)];
var p = Promise.race(arr);
var p2 = Promise.race(arr2);

console.log(p);
console.log(p2);
setTimeout(function(){
    console.log('the stack is now empty');
    console.log(p);
    console.log(p2);
});

// 로그 출력 결과 (순서대로):
// Promise { <state>: "pending" } 
// Promise { <state>: "pending" } 
// the stack is now empty
// Promise { <state>: "fulfilled", <value>: 666 }
// Promise { <state>: "fulfilled", <value>: "프로미스 아님" }
```

#### Promise 의 비판
- 여전히 콜백을 사용한다.
- 가독성이 좋지 않다.

### 비동기 함수 (Async Function)  
- ES2017 에 도입
- 동기식 코드와 거의 같은 구조의 비동기식 코드를 짤 수 있다.

비동기 함수
```javascript
async function func1() {
  // ...
}
```

비동기 화살표 함수
```javascript
const func2 = async () => {
  // ...
}
```
비동기 메소드
```javascript
class MyClass {
  async myMethod() {
    // ...
  }
}
```
    
- Promise 객체를 반환한다.
- 비동기 함수 내에서 return 한 값이, Promise 객체의 결과값이다.
```javascript
async function func1() {
  return 1;
}

async function func2() {
  return Promise.resolve(2);
}

func1().then(console.log); // 1
func2().then(console.log); // 2
```

#### await 키워드
- await 키워드 뒤에 오는 Promise 가 결과값을 가질 때까지 비동기 함수의 실행을 중단시킨다.
- await 연산의 결과 값
    - 뒤에 오는 Promise 객체의 결과값

```javascript
// Promise 객체를 반환하는 함수.
function delay(ms) {
  return new Promise(resolve => {
    setTimeout(() => {
      console.log(`${ms} 밀리초가 지났습니다.`);
      resolve()
    }, ms);
  });
}

async function main() {
  await delay(1000);
  await delay(2000);
  const result = await Promise.resolve('끝');
  console.log(result);
}

main();
//  1000 밀리초가 지났습니다.
//  2000 밀리초가 지났습니다.
//  끝
```

앞서 나오던 복잡한 예제의 Callback Promise 코드와 비교해 보자
```javascript
const axios = require('axios');
const API_URL = 'https://api.github.com';

async function fetchStarCount() {
  const starCount = {};

  // 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다.
  const topRepoRes = await axios.get(`${API_URL}/search/repositories?q=language:javascript&sort=stars&per_page=1`);

  // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다.
  const topMemberRes = await axios.get(`${API_URL}/repos/${topRepoRes.data.items[0].full_name}/contributors?per_page=5`);

  // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다.
  const ps = topMemberRes.data.map(user => axios.get(`${API_URL}/users/${user.login}/starred?per_page=10`));
  const starredReposRess = await Promise.all(ps);
  const starredReposData = starredReposRess.map(r => r.data);

  // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다.
  for (let repoArr of starredReposData) {
    for (let repo of repoArr) {
      if (repo.full_name in starCount) {
        starCount[repo.full_name]++;
      } else {
        starCount[repo.full_name] = 1;
      }
    }
  }
  return starCount;
}

fetchStarCount().then(console.log);
```

### Generator
함수를 잠수 멈춰둘 수 있는 generator 의 특징을 이용해 비동기 프로그래밍을 위해 사용되기도 한다.

ES2017 의 비동기함수가 도입되기 전, generator 가 비동기 프로그래밍을 위해 널리 사용되었다고한다.

#### Generator 의 장점
- 함수의 재개를 프로그래머가 직접 제어할 수 있다.
- redux-saga 에서도 Generator 를 사용하고 있다.

- generator 를 비동기식으로 작동시킬 수 있는 co 라이브러리를 사용
- Github에서 데이터를 불러오는 예제를 다시 작성
```javascript
const co = require('co');
const axios = require('axios');
const API_URL = 'https://api.github.com';

function* fetchStarCount() {
  const starCount = {};

  // 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다.
  const topRepoRes = yield axios.get(`${API_URL}/search/repositories?q=language:javascript&sort=stars&per_page=1`);

  // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다.
  const topMemberRes = yield axios.get(`${API_URL}/repos/${topRepoRes.data.items[0].full_name}/contributors?per_page=5`);

  // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다.
  const ps = topMemberRes.data.map(user => axios.get(`${API_URL}/users/${user.login}/starred?per_page=10`));
  const starredReposRess = yield Promise.all(ps);
  const starredReposData = starredReposRess.map(r => r.data);

  // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다.
  for (let repoArr of starredReposData) {
    for (let repo of repoArr) {
      if (repo.full_name in starCount) {
        starCount[repo.full_name]++;
      } else {
        starCount[repo.full_name] = 1;
      }
    }
  }
  return starCount;
}

co(fetchStarCount).then(console.log);
```



Reference & Comment
--
- https://gitlab.com/siots-study/topics/-/wikis/asyncronous
- https://www.youtube.com/watch?v=JaHlR1IGLN8&list=PL7jH19IHhOLMmmjrwCi7-dMFVdoU0hhgF
- https://helloworldjavascript.net/pages/285-async.html
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/race
- https://ko.javascript.info/async
- https://www.bsidesoft.com/8325

- https://www.bsidesoft.com/6037
- https://ko.javascript.info/generators-iterators