# 비동기 프로그래밍

## Motivation - 타이머 API
자바스크립트 개념이 아닌 브라우저와 node.js 에서 부터 왔다. 
      
setTimeout 
- 인자 (callback, msTime) : msTime 후에 callback 실행
- msTime : callback 이 실행의 최소 대기시간, 지연될 수 있다.

setInterval 
- msTime 을 1000ms 이하로 지정하였을 때
    - 브라우저에 따라 msTime 을 강제로 set 시킨다. 
    - 크롬의 경우, 1000ms 으로 set 한다.

여기서 왜 setTimeout 의 일정시간을 지키지 않고 지연되어 실행되는 이유가 무엇인지 알아보자.



## 브라우저의 JavaScript 코드 실행 과정
### 호출 스택 (Call Stack)
JS 엔진은 함수 호출 관련정보를 콜스택에서 관리한다.

```javascript
function add(x, y) {
  return x + y;
}

function add2(x) {
  return add(x, 2); // `add`를 호출
}

function add2AndPrint(x) {
  const result = add2(x); // `add2`를 호출
  console.log(result); // `console.log`를 호출
}

add2AndPrint(3); // `add2AndPrint`를 호출
```
위 코드의 호출스택 상태 변화는 아래와 같다.  
 
<img src="https://user-images.githubusercontent.com/31977543/91665967-54b20100-eb34-11ea-87fb-0db6b7b7b4fa.png" style="width: 200px"/>
<img src="https://user-images.githubusercontent.com/31977543/91665973-61cef000-eb34-11ea-8418-f8d9b1ca4429.png" style="width: 200px"/>
<img src="https://user-images.githubusercontent.com/31977543/91665980-70b5a280-eb34-11ea-8e4e-2c9d0f5dad78.png" style="width: 200px"/>
<img src="https://user-images.githubusercontent.com/31977543/91665973-61cef000-eb34-11ea-8418-f8d9b1ca4429.png" style="width: 200px"/>
<img src="https://user-images.githubusercontent.com/31977543/91665967-54b20100-eb34-11ea-87fb-0db6b7b7b4fa.png" style="width: 200px"/>

### 실행 맥락 (Execution context)
call stack 에 저장되는 각 항목

#### Execution Context 의 요소들
[렉시컬 환경](./렉시컬%20환경)

- Environment Record
    - 함수 내부에서 사용되는 변수 
    - this 가 가리치는 객체 
- outer Lexical Environment 

### 브라우저가 JavaScript 코드를 실행할 때, 호출 스택의 변화
1. 스크립트를 로드 할 때
    - **전역실행맥락(Global Execution Context)** 을 호출 스택에 push
1. 함수가 호출 될 때
    - 함수 호출의 실행 맥락 생성
    - **함수 호출의 실행 맥락**을 호출 스택에 push
1. 함수의 실행이 끝날 때
    - 결과값 반환
    - 호출 스택의 가장 위에 있는 실행 맥락 pop
1. 스크립트의 실행이 모두 끝날 때
    - 전역 실행 맥락을 호출 스택에서 pop
    
웹 브라우저는 호출 스택에 실행 맥락이 존재하는 동안(실행 중인 함수가 존재하는 동안) 먹통이 된다.
- 브라우저의 주사율, 보통 60fps, 대략 16 ms 안에 코드 실행을 완료되지 않으면
    - 브라우저 내 애니매이션이 뚝뚝 끊기는 현상
    - 사용자 경험에 악영향

### 작업 큐 (Task Queue)
작업 큐에는 16 ms 안에 처리하는 것이 어려운 일들 이 들어간다.
- event 를 기다리는 일
- 계산이 오래걸리는 작업
- 스크립트나 모듈을 로딩하는 동작

### 브라우저의 행동 : 이벤트 루프 (Event Loop)
브라우저가 아래 행동을 끊임 없이 반복하는 것을 이벤트 루프라고 부른다.

1. 태스크 처리 위임
    - From : JS 엔진
    - To : API 를 통해(TODO)
        - 브라우저 혹은 Web Worker(message 이벤트에 이벤트 리스너 등록) 에 위임
        - 태스크가 끝나면 실행시킬 `콜백` 등록
1. 위임된 태스크가 끝남
    - 태스크의 **반환값**과 **콜백**을 작업 큐(task queue) 에 추가
1. 브라우저는 호출 스택이 비워질 때 마다
    - 작업 큐에서 가장 오래된 작업을 꺼낸다.
    - 작업에 대한 콜백을 실행 시킨다. 

<embed src="https://helloworldjavascript.net/images/eventloop.svg" onload="onKSLoad(this)" data-loop="">

### 호출 스택과 작업 큐의 성질
1. 호출 스택이 비워져야 Task Queue 의 다음 태스크가 실행된다.
1. 각 태스크 사이에 브라우저는 화면을 새로 그릴 수 있다.
    - 호출스택이 비워질 때

## 비동기 프로그래밍 Asynchronous Programming

### 비동기 & 동기 프로그래밍
비동기 프로그래밍
- 태스크의 완료를 기다리지 않고 다음 코드를 실행해 나간다.
동기식 프로그래밍
- 태스크가 완료될 때까지 코드의 실행을 멈추고 기다린다.

### 비동기 프로그래밍의 특징
- 장점 : 대개 프로그램의 성능과 응답성을 높인다.
- 단점 : 코드의 실행 순서가 뒤죽박죽이 된다.
    - 코드의 가독성 저하
    - 디버깅의 어려움
    
## 비동기 프로그래밍 기법
비동기 프로그래밍의 단점을 극복하기 위한 JavaScript 의 프로그래밍 기법들이 존재한다.

### 콜백 (Callback)
다른 함수의 인수로 넘기는 함수

예시) Github 의 create-react-app 프로젝트에 등록되어 있는 이슈 목록을 가져와서 출력하는 코드
```javascript
const $ = require('jquery');
const API_URL = 'https://api.github.com/repos/facebookincubator/create-react-app/issues?per_page=10';

$.ajaxSetup({
  dataType: 'json'
});

$.get(API_URL, issues => {
  console.log('최근 10개의 이슈:');
  issues
    .map(issue => issue.title)
    .forEach(title => console.log(title));
  console.log('출력이 끝났습니다.');
});

console.log('받아오는 중...');
```
- $.get 메소드
    - 비동기식 동작
    - Github API 서버 통신 태스크를 브라우저에 위임한 후 종료된다.
    - 통신이 끝난 후 그 결과를 첫번째 인수로 해서 콜백을 호출한다.
   
더 복잡한 예시) 
1. Github 에 공개되어있는 저장소 중, 언어가 JavaScript 이고 별표를 가장 많이 받은 저장소를 불러온다.
1. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다.
1. 해당 기여자들이 최근에 Github 에서 별표를 한 저장소를 각각 10개씩 불러온다.
1. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다.

데이터 흐름이 조금만 복잡해져도 코드가 복잡해지는 문제가 생긴다.

```javascript
const $ = require('jquery');
const API_URL = 'https://api.github.com';
const starCount = {};

$.ajaxSetup({
  dataType: 'json'
});

// 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다.
$.get(`${API_URL}/search/repositories?q=language:javascript&sort=stars&per_page=1`, result => {
  // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다.
  $.get(`${API_URL}/repos/${result.items[0].full_name}/contributors?per_page=5`, users => {
    let repoArrs = [];
    for (let user of users) {
      // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각 기여자마다 10개씩 불러온다.
      $.get(`${API_URL}/users/${user.login}/starred?per_page=10`, repos => {
        repoArrs.push(repos);
        // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다.
        if (repoArrs.length === 5) {
          for (let repoArr of repoArrs) {
            for (let repo of repoArr) {
              if (repo.full_name in starCount) {
                starCount[repo.full_name]++;
              } else {
                starCount[repo.full_name] = 1;
              }
            }
          }
          console.log(starCount);
        }
      });
    }
  });
});

console.log('fetching...');
```

#### 콜백의 에러 처리
```javascript
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`${src}를 불러오는 도중에 에러가 발생했습니다.`));

  document.head.append(script);
}

loadScript('/my/script.js', function(error, script) {
  if (error) {
    // 에러 처리
  } else {
    // 스크립트 로딩이 성공적으로 끝남
  }
});

```

### Promise 
언젠가 끝나는 작업의 결과값을 담는 객체

#### Promise 객체 생성
정적 메서드 `Promise.resolve`
```javascript
const p = Promise.resolve(1);
```
(Promise 프로퍼티: result - value : 1) 을 갖는 Promise 객체 생성

#### 비동기 작업을 하는 Promise 객체 생성
```javascript
const p = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log('2초가 지났습니다. ');
        resolve('hello');
    }, 2000);
})
```

#### Promise 생성자
- Promise 생성자의 인수 : 콜백
    - 이 콜백을 executor(실행자, 실행 함수) 라고 부른다.
    - new Promise 가 만들어 질 때 자동으로 실행된다
- Executor 의 인수
    - resolve & reject : 자바스크립트 엔진이 미리 정의한 함수
    1. resolve(value)
        - 일이 성공적으로 끝난 경우 Executor 안에서 resolve(value) 를 호출
        - (value)이 Promise 객체의 result 값
    2. reject(error)
        - 에러 발생 시 에러 객체를 나타내는 error 와 함께 호출

#### Promise 객체의 내부 프로퍼티
- state
    - pending (대기) : 처음 값
    - settled : 처리된 Promise
        1. fulfilled (이행) : resolve 가 호출 될 때
        1. rejected (거부됨) : reject 가 호출 될 때
- result
    1. undefined : 처음 값
    2. value : resolve(value) 가 호출 될 때
    3. error : reject(error) 가 호출될 때
    
![image](https://user-images.githubusercontent.com/31977543/91831267-d2822380-ec7e-11ea-8422-e68fc9d6787c.png)

#### 처리된 Promise 핸들러는 즉각 실행된다.
.then/catch/finally 핸들러는 Promise 가 처리되길 기다린다.

만약 Promise 가 이미 처리된 상태라면 즉각 실행된다.
```javascript
// 아래 프라미스는 생성과 동시에 이행됩니다.
let promise = new Promise(resolve => resolve("완료!"));
promise.then(alert); // 완료! (바로 출력됨)
```

#### Promise Executor 와 Handler 의 Error 처리
보이지 않는 try..catch 가 있다. 
1. 예외를 잡고 이를 reject 처럼 다룬다.
1. 제어의 흐름이 가장 가까운 에러 핸들러로 넘어간다.

```javascript
new Promise((resolve, reject) => {
  throw new Error("에러 발생!");    //   reject(new Error("에러 발생!"));
}).catch(alert); // Error: 에러 발생!
```


#### then : Promise 결과값에 대한 추가 작업
- Promise 객체에 then 메서드를 사용할 수 있다.

##### then Parameter
1. Promise 가 이행되었을 때 실행하는 함수
    - 콜백의 첫번째 인수 : Promise 객체의 결과값
2. Promise 가 거부되었을 때 실행하는 함수
    - 콜백의 첫번쨰 인수 : 에러
    
```javascript
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("done!"), 1000);
});

// resolve 함수는 .then의 첫 번째 함수(인수)를 실행합니다.
promise.then(
  result => alert(result), // 1초 후 "done!"을 출력
  error => alert(error) // 실행되지 않음
);
```
```javascript
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => reject(new Error("에러 발생!")), 1000);
});

// reject 함수는 .then의 두 번째 함수를 실행합니다.
promise.then(
  result => alert(result), // 실행되지 않음
  error => alert(error) // 1초 후 "Error: 에러 발생!"를 출력
);
```
```javascript
let promise = new Promise(resolve => {
  setTimeout(() => resolve("done!"), 1000);
});

promise.then(alert); // 1초 뒤 "done!" 출력

promise.then(msg => {
  console.log(msg); // hello
});
```
- then 메서드의 반환 값 : Promise 객체
- then 메서드의 return 값 : Promise 객체의 결과 값

```javascript
const promise = promise.then(msg => {
  return msg + ' world';
});

promise2.then(msg => {
  console.log(msg); // hello world
});
```
```javascript
promise.then(msg => {
  return msg + ' world';
}).then(msg => {
  console.log(msg);
});
```

#### catch
에러가 발생한 경우만 다루고 싶을 때

1. null 을 then 의 첫번째 인수로 전달한다.
    `.then(null, errorHandlingFunction)`
1. `.catch(errorHandlingFunction)`

두가지 방식은 똑같이 동작한다.

```javascript
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("에러 발생!")), 1000);
});

// .catch(f)는 promise.then(null, f)과 동일하게 작동합니다
promise.catch(alert); // 1초 뒤 "Error: 에러 발생!" 출력
```

에러가 성공적으로 처리되면, 가장 가까운 곳에 있는 .then 핸들러로 제어흐름이 넘어가 실행이 이어진다.
```javascript
new Promise((resolve, reject) => {
  throw new Error("에러 발생!");
}).catch(function(error) {
  alert("에러가 잘 처리되었습니다. 정상적으로 실행이 이어집니다.");
}).then(() => alert("다음 핸들러가 실행됩니다."));
```

에러가 성공적으로 처리되지 않았을 때, 에러를 다시 던진다.
```javascript
// 실행 순서: catch -> catch
new Promise((resolve, reject) => {
  throw new Error("에러 발생!");
}).catch(function(error) { // (*)
  if (error instanceof URIError) {
    // 에러 처리
  } else {
    alert("처리할 수 없는 에러");
    throw error; // 에러 다시 던지기
  }
}).then(function() {
  /* 여기는 실행되지 않습니다. */
}).catch(error => { // (**)
  alert(`알 수 없는 에러가 발생함: ${error}`);
  // 반환값이 없음 => 실행이 계속됨
});
```

##### unhandledrejection
거부된 Promise 를 처리하지 못할 경우 자바스크립트 엔진은 전역 에러를 발생시킨다.
브라우저 환경에선 이런 에러를 `unhandledrejection` 이벤트로 잡을 수 있다.
```javascript
window.addEventListener('unhandledrejection', function(event) {
  // 이벤트엔 두 개의 특별 프로퍼티가 있습니다.
  alert(event.promise); // [object Promise] - 에러를 생성하는 프라미스
  alert(event.reason); // Error: 에러 발생! - 처리하지 못한 에러 객체
});

new Promise(function() {
  throw new Error("에러 발생!");
}); // 에러 처리 핸들러, catch가 없음
```

- 처리되지 않은 에러 추적
- 이런 에러를 사용자(혹은 서버)에게 알려서 앱이 아무런 설명없이 '그냥 죽는걸' 방지한다.

##### setTimeout 에서의 에러
```javascript
new Promise(function(resolve, reject) {
  setTimeout(() => {
    throw new Error("에러 발생!");
  }, 1000);
}).catch(alert);
```
모든 동기적 에러는 try..catch 에서 처리되지만
setTimeout 은 Executor 가 끝난 후 발생하기 때문에 Promise 에서 에러를 처리할 수 없다.

#### finally
Promise 처리가 완료되면, 결과와 상관없이 finally 문이 실행된다.
 
- finally 핸들러(콜백의 이름)
    - 인수가 없다.
    - Promise 의 settled 상태를 알 수 없다
    - 자동으로 다음 핸들러에 결과와 에러를 전달한다.
    
```javascript
new Promise((resolve, reject) => {
  setTimeout(() => resolve("결과"), 2000)
})
  .finally(() => alert("프라미스가 준비되었습니다."))
  .then(result => alert(result)); // <-- .then에서 result를 다룰 수 있음

new Promise((resolve, reject) => {
  throw new Error("에러 발생!");
})
  .finally(() => alert("프라미스가 준비되었습니다."))
  .catch(err => alert(err)); // <-- .catch에서 에러 객체를 다룰 수 있음
```

#### HTTP 통신의 Promise
`axios.get()` 함수는 Promise 객체를 반환한다.

```javascript
const axios = require('axios');
const API_URL = 'https://api.github.com';

axios.get(`${API_URL}/repos/facebookincubator/create-react-app/issues?per_page=10`)
  .then(res => {
    console.log('최근 10개의 이슈:');
    res.data
      .map(issue => issue.title)
      .forEach(title => console.log(title));
    console.log('출력이 끝났습니다.');
  });
```

콜백의 비동기 프로그래밍의 복잡한 예시와 코드를 비교해 보자
```javascript
const API_URL = 'https://api.github.com';
const starCount = {};
const axios = require('axios');

// 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다.
axios.get(`${API_URL}/search/repositories?q=language:javascript&sort=stars&per_page=1`)
  // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다.
  .then(res => axios.get(`${API_URL}/repos/${res.data.items[0].full_name}/contributors?per_page=5`))
  // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다.
  .then(res => {
    const ps = res.data.map(user => axios.get(`${API_URL}/users/${user.login}/starred?per_page=10`));
    return Promise.all(ps);
  })
  .then(ress => Promise.all(ress.map(r => r.data)))
  // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다.
  .then(repoArrs => {
    for (let repoArr of repoArrs) {
      for (let repo of repoArr) {
        if (repo.full_name in starCount) {
          starCount[repo.full_name]++;
        } else {
          starCount[repo.full_name] = 1;
        }
      }
    }
    console.log(starCount);
  });

console.log('fetching...');
```

앞서 콜백으로 구현된 loadScript 를 Promise 로 나타내어 봅시다.
```javascript
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`${src}를 불러오는 도중에 에러가 발생함`));

  document.head.append(script);
}
``` 
```javascript
function loadScript(src) {
  return new Promise(function(resolve, reject) {
    let script = document.createElement('script');
    script.src = src;

    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`${src}를 불러오는 도중에 에러가 발생함`));

    document.head.append(script);
  });
}

let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");

promise.then(
  script => alert(`${script.src}을 불러왔습니다!`),
  error => alert(`Error: ${error.message}`)
);

promise.then(script => alert('또다른 핸들러...'));
```

콜백의 setTimeout 을 Promise 로 만들기
```javascript
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
delay(3000).then(() => alert('3초후 실행'));
```

#### Promise.all(iterable) 
여러 프로미스의 결과를 집계할 때 사용한다.

```javascript
const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});

Promise.all([promise1, promise2, promise3]).then((values) => {
  console.log(values);
});
// expected output: Array [3, 42, "foo"]
```

##### 매개변수
`iterable` 객체
- 프로미스가 아닌 값을 포함할 수 있다.
- 이미 이행된 프로미스 객체를 포함할 수 있다. 

##### 반환 값
iterable 의 Promise 가 모두 처리되면 새로운 Promise 를 이행한다. 
그리고 iterable 의 Promise 들의 결과값을 담은 배열이 새로운 Promise 의 result 가 된다. 
- iterable 객체가 비어있을 때 
    - 이미 이행한 Promise 반환. 
- iterable 객체 중 프로미스가 없을 때
    - 비동기 적으로 이행하는 Promise.
    - 크롬 58 은 이미 이행한 프로미스 반환  
- 위의 두가지에 해당되지 않을 때
    - Promise 가 모두 이행 된 후, 새 Promise 객체를 반환한다.
    - 요소 중 하나라도 거부가 될 때, reject 된다. 
        - reject 가 발생해도 취소되지 않고, 나머지 Promise 도 결과를 산출하지만 무시된다.
        - AbortController 를 사용하면 프로미스 취소가 가능하다.

아래의 예시에서 뜻을 확인할 수 있다.

##### Promise.all 의 동기성/ 비동기성

Promise.all 의 비동기성을 보이는 예제 
```javascript
// Promise.all을 최대한 빨리 완료시키기 위해
// 이미 이행된 프로미스로 배열을 만들어 인자로 전달 
var resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)];

var p = Promise.all(resolvedPromisesArray);
// 실행 즉시 p의 값을 기록
console.log(p);

// 호출 스택을 비운 다음 실행하기 위해 setTimeout을 사용
setTimeout(function() {
    console.log('the stack is now empty');
    console.log(p);
});

// 로그 출력 결과 (순서대로):
// Promise { <state>: "pending" } 
// the stack is now empty
// Promise { <state>: "fulfilled", <value>: Array[2] }
```

Promise.all()이 거부하는 경우에도 비동기성을 보인다
```javascript
var mixedPromisesArray = [Promise.resolve(33), Promise.reject(44)];
var p = Promise.all(mixedPromisesArray);
console.log(p);
setTimeout(function() {
    console.log('the stack is now empty');
    console.log(p);
});

// 출력
// Promise { <state>: "pending" } 
// the stack is now empty
// Promise { <state>: "rejected", <reason>: 44 }
```

- iterable 객체가 비어있는 경우에는 동기적으로 이행된다.
- 프로미스가 아닌 값은 무시하지만 비동기적으로 실행됨 
```javascript
var p = Promise.all([]); // 즉시 이행함
var p2 = Promise.all([1337, "hi"]); // 프로미스가 아닌 값은 무시하지만 비동기적으로 실행됨
console.log(p);
console.log(p2);
setTimeout(function() {
    console.log('the stack is now empty');
    console.log(p2);
});

// 출력
// Promise { <state>: "fulfilled", <value>: Array[0] }
// Promise { <state>: "pending" }
// the stack is now empty
// Promise { <state>: "fulfilled", <value>: Array[2] }
```

##### 예시
복수의 URL 에 동시에 요청을 보내고, 다운로드가 모두 완료된 후에 콘텐츠를 처리할 때.
```javascript
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://api.github.com/users/jeresig'
];

// fetch를 사용해 url을 프라미스로 매핑합니다.
let requests = urls.map(url => fetch(url));

// Promise.all은 모든 작업이 이행될 때까지 기다립니다.
Promise.all(requests)
  .then(responses => responses.forEach(
    response => alert(`${response.url}: ${response.status}`)
  ));
```

#### Promise.allSettled
- Promise.all 과 다르게, 모든 Promise 가 처리될 때까지 기다린다.
- 여러 요청 중 하나가 실패해도 다른 요청 결과는 여전히 있어야 할 때

```text
[
  {status: 'fulfilled', value: ...응답...},
  {status: 'fulfilled', value: ...응답...},
  {status: 'rejected', reason: ...에러 객체...}
]
```

#### Promise.race(iterable)

TODO 실제로 어떨때 사용이 될까?

- Promise 객체를 반환
    - iterable 에서 처음으로 이행하거나 거부한 프로미스의 값을 비동기적으로 전달받는, 대기중인 Promise
    - iterable 이 비어있을 경우
        - 반환한 Promise 는 영원히 대기 상태가 된다.
    - iterable 에 프로미스가 아닌값, 이미 완료된 프로미스가 포함될 경우
        - 전달받은 iterable 에서 처음으로 등장하는 이러한 값을 결과값으로 이행한다

- Promise.race 의 비동기성
    ```javascript
    // Promise.race를 최대한 빨리 완료시키기 위해
    // 이미 이행된 프로미스로 배열을 만들어 인자로 전달
    var resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)];
    
    var p = Promise.race(resolvedPromisesArray);
    // 실행 즉시 p의 값을 기록
    console.log(p);
    
    // 호출 스택을 비운 다음 실행하기 위해 setTimeout을 사용
    setTimeout(function(){
        console.log('the stack is now empty');
        console.log(p);
    });
    
    // 로그 출력 결과 (순서대로):
    // Promise { <state>: "pending" }
    // the stack is now empty
    // Promise { <state>: "fulfilled", <value>: 33 }
    ```    

- 비어있는 iterable : 프로미스는 영원히 대기 상태가 된다.
    ```javascript
    var foreverPendingPromise = Promise.race([]);
    console.log(foreverPendingPromise);
    setTimeout(function(){
        console.log('the stack is now empty');
        console.log(foreverPendingPromise);
    });
    
    // 로그 출력 결과 (순서대로):
    // Promise { <state>: "pending" }
    // the stack is now empty
    // Promise { <state>: "pending" }
    ```
- iterable 에 프로미스가 아닌 값 || 이미 완료된 프로미스 
    - 전달받은 iterable 에서 처음으로 등장하는 이러한 값을 결과값으로 이행한다 

```javascript
var foreverPendingPromise = Promise.race([]);
var alreadyFulfilledProm = Promise.resolve(666);

var arr = [foreverPendingPromise, alreadyFulfilledProm, "프로미스 아님"];
var arr2 = [foreverPendingPromise, "프로미스 아님", Promise.resolve(666)];
var p = Promise.race(arr);
var p2 = Promise.race(arr2);

console.log(p);
console.log(p2);
setTimeout(function(){
    console.log('the stack is now empty');
    console.log(p);
    console.log(p2);
});

// 로그 출력 결과 (순서대로):
// Promise { <state>: "pending" } 
// Promise { <state>: "pending" } 
// the stack is now empty
// Promise { <state>: "fulfilled", <value>: 666 }
// Promise { <state>: "fulfilled", <value>: "프로미스 아님" }
```

#### Promise.resolve(value)
result 가 value 인 이행 상태 프라미스를 생성

`let promise = new Promise(resolve => resolve(value));` 와 동일한 수행을 한다.

function loadCached(URL)
- URL을 대상으로 fetch를 호출하고, 그 결과를 기억(cache)합니다. 
- 동일한 URL을 대상으로 fetch를 호출하면, Promise.resolve 를 사용해 캐시 된 내용을 Promise 로 만들어 반환 값이 항상 Promise 가 되게 합니다.
- loadCached 를 호출하면 프라미스가 반환된다는 것이 보장되기 때문에 loadCached(url).then(…)을 사용할 수 있습니다. 

```javascript
let cache = new Map();

function loadCached(url) {
  if (cache.has(url)) {
    return Promise.resolve(cache.get(url)); // (*)
  }

  return fetch(url)
    .then(response => response.text())
    .then(text => {
      cache.set(url,text);
      return text;
    });
}
```

#### Promise.reject(error)
result 가 error 인 거부상태 Promise 생성
`let promise = new Promise((resolve, reject) => reject(error));` 와 동일한 기능을 한다.

#### 프로미스화 Promisification
콜백을 받는 함수를 Promise 를 반환하는 함수로 바꾸는 것
- 콜백 보다는 Promise 가 더 편리하다.
- 콜백기반 라이브러리를 Promise 를 반환하는 함수로 바꿀 수 있다.
- Node.js 내장 함수 util.promisify
- 모듈 es6-promisify


```javascript
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`${src}를 불러오는 도중에 에러가 발생함`));

  document.head.append(script);
}
// usage:
// loadScript('path/script.js', (err, script) => {...})
```
```javascript
let loadScriptPromise = function(src) {
  return new Promise((resolve, reject) => {
    loadScript(src, (err, script) => {
      if (err) reject(err);
      else resolve(script);
    });
  })
}

// 사용법:
// loadScriptPromise('path/script.js').then(...)
```

#### 마이크로 태스크
Promise 핸들러 .then/catch/finally 는 항상 비동기적으로 실행된다.

Promise 가 즉시 이행되더라도, 마찬가지 이다.
```javascript
et promise = Promise.resolve();

promise.then(() => alert("프라미스 성공!"));  // 2

alert("코드 종료"); // 1
```

##### 마이크로태스크 큐
비동기 작업을 처리하기 위한 `PromiseJobs` 라고 불리는 내부 큐(internal queue).

V8 엔진에서는 microtask queue 라고 부른다.

- FIFO, 먼저 들어온 작업을 먼저 실행
- 실행할 것(호출 스택)이 비었을 때만 마이크로태스크큐의 작업이 실행된다.

어떤 Promise 가 준비되면 이 Promise 의 `.then/catch/finally` 핸들러가 큐에 들어가며, 실행되지 않은 상태이다.
- 큐가 실행되는 조건
    - 현재 코드의 실행이 완료될 때
    - 큐에 적재된 이전 핸들러의 실행이 완료될 때
  
브라우저/Node.js를 포함한 대부분의 자바스크립트 엔진에선, 마이크로태스크가 '이벤트 루프(event loop)'와 '매크로태스크(macrotask)'와 깊은 연관 관계를 맺는다. 
이 부분에 대해서는 주제 브라우저 에서 다시 다룰 것이다. TODO 


##### 처리되지 못한 거부 unhandledrejection
마이크로 태스트 큐 끝에서 Promise 가 처리되지 못할 때 발생한다.

에러가 잘 처리되었으므로 실행되지 않습니다.
```javascript
let promise = Promise.reject(new Error("프라미스 실패!"));
promise.catch(err => alert('잡았다!'));

window.addEventListener('unhandledrejection', event => alert(event.reason));
```

setTimeout 을 이용하여 에러를 나중에 처리할 경우
```javascript
let promise = Promise.reject(new Error("프라미스 실패!")); 
setTimeout(() => promise.catch(err => alert('잡았다!')), 1000); // '잡았다!' (2) 


window.addEventListener('unhandledrejection', event => alert(event.reason)); // Error: 프라미스 실패! (1)
```

- `unhandledrejection` 은 마이크로태스크 큐에 있는 작업 모두가 완료되었을 때 생성된다.
- `.catch` 는 `unhandledrejection` 이 발생한 이후에 트리거 된다.






#### Promise 장점
- then 메서드 : 콜백을 중첩하지 않고도 비동기 작업을 연이어 할 수 있다.
- 비동기 작업을 값으로 다룰 수 있다.

| Promise | Callback |
| --- | --- |
| 흐름이 자연스럽다. loadScript(script) 로 스크립트를 읽고, 결과에 따라 그 다음에 (then) 무엇을 할지에 대한 코드를 작성할 수 있다. | loadScript(script, callback) 을 호출할 때, 미리 callback 함수가 준비되어 있어야 한다. |
| 원하는 만큼 then 호출 가능. | 콜백은 하나만 가능하다. | 

#### Promise 의 비판
- 여전히 콜백을 사용한다.
- 가독성이 좋지 않다.

#### thenable 객체를 반환하는 핸들러
Promise 를 상속받지 않고도, 커스텀 객체를 사용해 프라미스 체이닝을 만드는 방법

thenable 객체
- .then 메서드를 가진 객체
- 서드 파티 라이브러리가 Promise 와 호환 가능한 자체 객체를 구현할 수 있다는 점에서 나왔다.

```javascript
class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve); // function() { 네이티브 코드 }
    // 1초 후 this.num*2와 함께 이행됨
    setTimeout(() => resolve(this.num * 2), 1000); // (**)
  }
}

new Promise(resolve => resolve(1))
  .then(result => {
    return new Thenable(result); // (*)
  })
  .then(alert); // 1000밀리 초 후 2를 보여줌
```

![image](https://user-images.githubusercontent.com/31977543/91840698-116aa600-ec8c-11ea-910b-94afef5e8cce.png)


### 비동기 함수 (Async Function)  
- ES2017 에 도입
- 동기식 코드와 거의 같은 구조의 비동기식 코드를 짤 수 있다.


#### async 키워드
- function 앞에 위치한다. 

비동기 함수
```javascript
async function func1() {
  // ...
}
```

비동기 화살표 함수
```javascript
const func2 = async () => {
  // ...
}
```
비동기 메소드
```javascript
class MyClass {
  async myMethod() {
    // ...
  }
}
```


항상 Promise 객체를 반환한다.
- function 이 Promise 가 아닌 값을 반환해도, 이행 상태의 Promise 로 감싸 반환한다.
- 비동기 함수 내에서 return 한 값이, Promise 객체의 result 값이다.
```javascript
async function func1() {
  return 1;
}

async function func2() {
  return Promise.resolve(2);
}

func1().then(console.log); // 1
func2().then(console.log); // 2
```


#### await 키워드
- async 함수 안에서만 동작한다.
- await 키워드 뒤에 오는 Promise 가 처리(settled) 될 때까지 비동기 함수의 실행을 중단시킨다.
    - Promise 가 처리되길 기다리는 동안엔 엔진이 다른일(다른 스크립트 실행, 이벤트 처리 등)을 하기 때문에 CPU 리소스가 낭비되지 않는다.
- await 연산의 결과 값
    - 뒤에 오는 Promise 객체의 결과값

```javascript
// Promise 객체를 반환하는 함수.
function delay(ms) {
  return new Promise(resolve => {
    setTimeout(() => {
      console.log(`${ms} 밀리초가 지났습니다.`);
      resolve()
    }, ms);
  });
}

async function main() {
  await delay(1000);
  await delay(2000);
  const result = await Promise.resolve('끝');
  console.log(result);
}

main();
//  1000 밀리초가 지났습니다.
//  2000 밀리초가 지났습니다.
//  끝
```

await 은 최상위 레벨 코드에서 동작하지 않으므로 IIFE 을 사용하자
- Deno 는 top-level await 을 지원한다.
```javascript
(async () => {
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();
  // ...
})();
```

await 은 thenable 객체를 받는다.
- resolve, reject 를 인수로 제공하는 .then 메서드를 호출한다.
```javascript
class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve);
    // 1000밀리초 후에 이행됨(result는 this.num*2)
    setTimeout(() => resolve(this.num * 2), 1000); // (*)
  }
};

async function f() {
  // 1초 후, 변수 result는 2가 됨
  let result = await new Thenable(1);
  alert(result);
}

f();
```


#### 에러 처리
```javascript
async function f() {
  try {
    let response = await fetch('http://유효하지-않은-주소');
  } catch(err) {
    alert(err); // TypeError: failed to fetch
  }
}
f();
```
```javascript
async function f() {
  let response = await fetch('http://유효하지-않은-url');
}

// f()는 거부 상태의 프라미스가 됩니다.
f().catch(alert); // TypeError: failed to fetch // (*)
```

예외 처리를 해주지 않으면. 처리되지 않은 Promise 에러가 발생한다. 
- `unhandledrejection` 전역 이벤트 핸들러를 이용해 잡을 수 있다.


#### Promise TO 비동기 함수
앞서 나오던 복잡한 예제의 Callback Promise 코드와 비교해 보자
```javascript
const axios = require('axios');
const API_URL = 'https://api.github.com';

async function fetchStarCount() {
  const starCount = {};

  // 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다.
  const topRepoRes = await axios.get(`${API_URL}/search/repositories?q=language:javascript&sort=stars&per_page=1`);

  // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다.
  const topMemberRes = await axios.get(`${API_URL}/repos/${topRepoRes.data.items[0].full_name}/contributors?per_page=5`);

  // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다.
  const ps = topMemberRes.data.map(user => axios.get(`${API_URL}/users/${user.login}/starred?per_page=10`));
  const starredReposRess = await Promise.all(ps);
  const starredReposData = starredReposRess.map(r => r.data);

  // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다.
  for (let repoArr of starredReposData) {
    for (let repo of repoArr) {
      if (repo.full_name in starCount) {
        starCount[repo.full_name]++;
      } else {
        starCount[repo.full_name] = 1;
      }
    }
  }
  return starCount;
}

fetchStarCount().then(console.log);
```

```javascript
function loadJson(url) {
  return fetch(url)
    .then(response => {
      if (response.status == 200) {
        return response.json();
      } else {
        throw new Error(response.status);
      }
    })
}

loadJson('no-such-user.json')
  .catch(alert); // Error: 404
```
```javascript
async function loadJson(url) { // (1)
  let response = await fetch(url); // (2)
  if (response.status == 200) {
    let json = await response.json(); // (3)
    return json;
  }
  throw new Error(response.status);
}
loadJson('no-such-user.json')
  .catch(alert); // Error: 404 (4)
```

#### async 가 아닌 함수에서 async 함수 호출하기
```javascript
async function wait() {
  await new Promise(resolve => setTimeout(resolve, 1000));
  return 10;
}

function f() {
  // shows 10 after 1 second
  wait().then(result => alert(result));
}

f();
```

### async Iterator
- `Symbol.iterator` 대신, `Symbol.asyncIterator`
- `next()` 는 Promise 를 반환
- `for await (let item of iterable)` 반복문

```javascript
let range = {
  from: 1,
  to: 5,

  // for await..of 최초 실행 시, Symbol.asyncIterator가 호출됩니다.
  [Symbol.asyncIterator]() { // (1)
    // Symbol.asyncIterator 메서드는 이터레이터 객체를 반환합니다.
    // 이후 for await..of는 반환된 이터레이터 객체만을 대상으로 동작하는데,
    // 다음 값은 next()에서 정해집니다.
    return {
      current: this.from,
      last: this.to,

      // for await..of 반복문에 의해 각 이터레이션마다 next()가 호출됩니다.
      async next() { // (2)
        //  next()는 객체 형태의 값, {done:.., value :...}를 반환합니다.
        // (객체는 async에 의해 자동으로 프라미스로 감싸집니다.)

        // 비동기로 무언가를 하기 위해 await를 사용할 수 있습니다.
        await new Promise(resolve => setTimeout(resolve, 1000)); // (3)

        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  }
};

(async () => {
    // next() 는 promise 를 반환하기 때문에 result 를 얻기 위해 await 를 붙여주어야 한다.
  for await (let value of range) { // (4)
    alert(value); // 1,2,3,4,5
  }

})()
```

... spread operator     
`alert( [...range] ); // Symbol.iterator가 없기 때문에 에러 발생`     

### async [Generator](./Iteration%20프로토콜.html)
일반함수
- (0, 1)개의 값만 반환


ES2017 의 비동기함수가 도입되기 전, generator 가 비동기 프로그래밍을 위해 널리 사용되었다고한다.

#### 일반 Generator 
- await 사용 불가
- 동기적 문법
- 여러 개의 값을 필요에 따라 하나씩 yield 반환 한다.
- 함수를 잠수 멈춰둘 수 있는 generator 의 특징을 이용해 비동기 프로그래밍을 위해 사용되기도 한다.
- 함수의 재개를 프로그래머가 직접 제어할 수 있다.
- redux-saga 에서도 Generator 를 사용하고 있다.


#### 제너레이터에 비동기 동작 추가
한번 콘솔로 돌려보자. 일반 제너레이터 함수와의 동작이 비교될 것이다.
```javascript
async function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) {
    // await를 사용할 수 있습니다!
    await new Promise(resolve => setTimeout(resolve, 1000));
    yield i;
  }
}

(async () => {
  let generator = generateSequence(1, 5);
  for await (let value of generator) {
    alert(value); // 1, 2, 3, 4, 5
  }
})();
```

### async Iterable
Symbol.iterator 는 next() 가 구현된 일반 객체보다, 제너레이터를 반환하도록 구현하는 경우가 더 많다.
```javascript
let range = {
  from: 1,
  to: 5,

  *[Symbol.iterator]() { // [Symbol.iterator]: function*()를 짧게 줄임
    for(let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }
};
```
비동기 동작을 추가한 generator
```javascript
let range = {
  from: 1,
  to: 5,

  async *[Symbol.asyncIterator]() { // [Symbol.asyncIterator]: async function*()와 동일
    for(let value = this.from; value <= this.to; value++) {

      // 값 사이 사이에 약간의 공백을 줌
      await new Promise(resolve => setTimeout(resolve, 1000));

      yield value;
    }
  }
};
```

#### 실제 사례
많은 온라인 서비스가 Pagination 을 구현해 데이터를 전송한다.
사용자 목록이 필요해서 서버에 요청을 보내면, 서버는 일정 숫자 단위로 사용자를 끊어 정보를 한 페이지로 구성한 후 다음페이지를 볼 수 있는 url 과 함께 응답한다.

```javascript
async function* fetchCommits(repo) {
  let url = `https://api.github.com/repos/${repo}/commits`;

  while (url) {
    const response = await fetch(url, { // (1)
      headers: {'User-Agent': 'Our script'}, // GitHub는 모든 요청에 user-agent헤더를 강제 합니다.
    });

    const body = await response.json(); // (2) 응답은 JSON 형태로 옵니다(커밋이 담긴 배열).

    // (3) 헤더에 담긴 다음 페이지를 나타내는 URL을 추출합니다.
    let nextPage = response.headers.get('Link').match(/<(.*?)>; rel="next"/);
    nextPage = nextPage?.[1];

    url = nextPage;

    for(let commit of body) { // (4) 페이지가 끝날 때까지 커밋을 하나씩 반환(yield)합니다.
      yield commit;
    }
  }
}
(async () => {
  let count = 0;
  for await (const commit of fetchCommits('javascript-tutorial/en.javascript.info')) {
    console.log(commit.author.login);
    if (++count == 100) { // 100번째 커밋에서 멈춥니다.
      break;
    }
  }
})();
```


generator 를 비동기식으로 작동시킬 수 있는 co 라이브러리를 사용

- Github에서 데이터를 불러오는 예제를 다시 작성
```javascript
const co = require('co');
const axios = require('axios');
const API_URL = 'https://api.github.com';

function* fetchStarCount() {
  const starCount = {};

  // 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript 이고 별표를 가장 많이 받은 저장소를 불러온다.
  const topRepoRes = yield axios.get(`${API_URL}/search/repositories?q=language:javascript&sort=stars&per_page=1`);

  // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다.
  const topMemberRes = yield axios.get(`${API_URL}/repos/${topRepoRes.data.items[0].full_name}/contributors?per_page=5`);

  // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다.
  const ps = topMemberRes.data.map(user => axios.get(`${API_URL}/users/${user.login}/starred?per_page=10`));
  const starredReposRess = yield Promise.all(ps);
  const starredReposData = starredReposRess.map(r => r.data);

  // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다.
  for (let repoArr of starredReposData) {
    for (let repo of repoArr) {
      if (repo.full_name in starCount) {
        starCount[repo.full_name]++;
      } else {
        starCount[repo.full_name] = 1;
      }
    }
  }
  return starCount;
}

co(fetchStarCount).then(console.log);
```

### iterable & generator 요약
| | iterable | async iterable | 
| --- | --- | --- |
| iterator 를 반환하는 메서드 | Symbol.iterator | Symbol.asyncIterator |
| next() 가 반환하는 값 | { value:..., done: true/false } | { value:..., done: true/false } 를 감싸는 Promise |
 
| | generator | async generator | 
| --- | --- | --- |
| 선언 | function* | async function* |
| next() 가 반환하는 값 | { value:..., done: true/false } | { value:..., done: true/false } 를 감싸는 Promise |

웹개발을 하다보면 띄엄띄엄 들어오는 데이터 스트림을 다루어야 할 때가 자주 생긴다.
- 용량이 큰 파일 다운로드&업로드

이런 데이터를 처리할 때, async generator 를 사용할 수 있다.

몇몇 브라우저 및 호스트 환경에서는 데이터스트림을 처리해주는 API 를 제공하기도 한다.
- 한쪽에서 받은 데이터를 다른 쪽에 즉각 전달하는게 가능해진다.
(TODO)

Reference & Comment
--
- https://gitlab.com/siots-study/topics/-/wikis/asyncronous
- https://www.youtube.com/watch?v=JaHlR1IGLN8&list=PL7jH19IHhOLMmmjrwCi7-dMFVdoU0hhgF
- https://helloworldjavascript.net/pages/285-async.html
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/race
- https://ko.javascript.info/async
- https://ko.javascript.info/generators-iterators
- https://www.bsidesoft.com/8325

- https://www.bsidesoft.com/6037
